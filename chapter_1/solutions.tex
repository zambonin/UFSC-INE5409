\documentclass{article}

\usepackage[brazil]{babel}
\usepackage[T1]{fontenc}
\usepackage[a4paper, margin=1.5cm]{geometry}
\usepackage[colorlinks, urlcolor=blue]{hyperref}
\usepackage[utf8]{inputenc}
\usepackage{amsfonts, color, enumitem, listings, mathtools}

\newcommand\divr[1]{\multicolumn{1}{c|}{#1}}
\newcommand\redn[1]{\textcolor{red}{#1}}

\newenvironment{arabenum}{
    \begin{enumerate}[label=\textbf{\arabic*})]
}{
    \end{enumerate}
}

\newenvironment{alphenum}{
    \begin{enumerate}[label=(\alph*)]
}{
    \end{enumerate}
}

\newenvironment{bittable}[1]{
    \begin{tabular*}{\linewidth}{@{\extracolsep{\fill}}#1}
}{
    \end{tabular*}
}

\newenvironment{discusscode}[1]{
    \lstinputlisting[language=Python]{code/#1}
    \vspace{-2mm}
    \begin{itemize}
}{
    \end{itemize}
}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{colorcode}{
    commentstyle=\color{codegreen},
    keywordstyle=\color{blue},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\footnotesize\ttfamily,
    breaklines=true,
    showstringspaces=false,
}

\lstset{style=colorcode}

\begin{document}

{\bf \noindent Universidade Federal de Santa Catarina - UFSC \\
Centro Tecnológico - CTC \\
Departamento de Informática e Estatística - INE \\

\noindent Lista de Exercícios 1 - INE5202/INE5232/INE5409 \\
Prof. Sérgio Peters (\verb!sergio.peters@ufsc.br!)

\begin{center} Resoluções
\footnote{por Gustavo Zambonin (\texttt{gustavo.zambonin@grad.ufsc.br})}
\end{center}}

\begin{arabenum}

\item \begin{alphenum}

\item $(10.1011)_2 = 1 \cdot 2^1 + 1 \cdot 2^{-1} + 1 \cdot 2^{-3} +
1 \cdot 2^{-4} = \boldsymbol{(2.6875)_{10}}$

\item $(10.57)_{10} = (?)_2$
\begin{gather*}
\begin{array}{*{7}c}
(10)_{10} = (?)_2 \longrightarrow & \divr{10} & 2            \\ \cline{3-3}
                                  & \redn{0}  & \divr{5} & 2 \\ \cline{4-4}
&                                 & \redn{1}  & \divr{2} & 2 \\ \cline{5-5}
& &                               & \redn{0}  & \divr{1} & 2 \\ \cline{6-6}
& & &                             & \redn{1}  & \redn{0}
\end{array} \\
\longleftarrow \\
(10)_{10} = (1010)_2 = 1 \cdot 2^3 + 1 \cdot 2^1 \\
(0.57)_{10} = (?)_2 \longrightarrow \\
\begin{array}{*{15}c}
0.57 & 0.14 & 0.28 & 0.56 & 0.12 &
0.24 & 0.48 & 0.96 & 0.92 & 0.84 &
0.68 & 0.36 & 0.72 & 0.44 \\
\times 2 & \times 2 & \times 2 & \times 2 & \times 2 &
\times 2 & \times 2 & \times 2 & \times 2 & \times 2 &
\times 2 & \times 2 & \times 2 & \times 2 & \dots \\
\redn{1}.14 & \redn{0}.28 & \redn{0}.56 & \redn{1}.12 & \redn{0}.24 &
\redn{0}.48 & \redn{0}.96 & \redn{1}.92 & \redn{1}.84 & \redn{1}.68 &
\redn{1}.36 & \redn{0}.72 & \redn{1}.44 & \redn{0}.88
\end{array} \\
(0.57)_{10} = (0.10010001111010 \dots)_2
\end{gather*}

Logo, $(10.57)_{10} = \boldsymbol{(1010.10010001111010 \dots)_2}$.

\end{alphenum}

\item \begin{discusscode}{round.py}

\item A função \emph{reduce} é utilizada para criar o padrão requerido pelo
enunciado: uma lista de números onde todos os valores estão diretamente
relacionados a seus antecessores.

\item Aplica-se a fórmula do enunciado no último termo da lista a cada iteração,
por 10 vezes, iniciando pela inversa multiplicativa do número fornecido.

\item Adiciona-se então mais casas após à vírgula para melhor visualização de
como o arredondamento funciona.

\item O objetivo do algoritmo é verificar como os valores são influenciados
gradativamente por computações anteriores: estes perdem precisão
exponencialmente pois um valor decimal não pode ser representado perfeitamente
com um número finito de bits, exceto por potências de 2. A saída do algoritmo
mostra duas possibilidades para cada caso, e como a quantidade de bits
divergentes à divisão inicial, que já não se mostra exata, aumenta ao longo das
iterações.

\item Exemplo de saída (parcial) do programa:

\begin{verbatim}
0.333333333333333314829616256247
0.333333333333333259318465024990
0.333333333333333037273860099958
0.333333333333332149095440399833
0.333333333333328596381761599332
0.333333333333314385527046397328
0.333333333333257542108185589314
0.333333333333030168432742357254
0.333333333332120673730969429016
0.333333333328482694923877716064
0.333333333313930779695510864258
\end{verbatim}

\end{discusscode}

\item \begin{alphenum}

\item $(3021)_{F!} = 3 \cdot 4! + 0 \cdot 3! + 2 \cdot 2! + 1 \cdot 1! =
\boldsymbol{(77)_{10}}$

\item $(4321)_{F!} = 4 \cdot 4! + 3 \cdot 3! + 2 \cdot 2! + 1 \cdot 1! =
\boldsymbol{(119)_{10}}$

\item $(10000)_{F!} = 1 \cdot 5! = \boldsymbol{(120)_{10}}$

\item $(0.02)_{F!} = \frac{0}{2!} + \frac{2}{3!} = (\frac{2}{6})_{10} =
(\frac{1}{3})_{10} = \boldsymbol{(0.333333 \dots)_{10}}$

\item $(0.113)_{F!} = \frac{1}{2!} + \frac{1}{3!} + \frac{3}{4!} =
(\frac{19}{24})_{10} = \boldsymbol{(0.791\overline{6} \dots)_{10}}$

\item $(321.123)_{F!} = 3 \cdot 3! + 2 \cdot 2! + 1 \cdot 1! + \frac{1}{2!} +
\frac{2}{3!} + \frac{3}{4!} = (\frac{575}{24})_{10} =
\boldsymbol{(23.958\overline{3})_{10}}$

\end{alphenum}

\item \begin{alphenum}

\item $(10111.1101)_2 = (0001 \; 0111.1101)_2 = (17.D)_{16} = 1 \cdot 16^1 +
7 \cdot 16^0 + 13 \cdot 16^{-1} = (\frac{381}{16})_{10} =
\boldsymbol{(23.8125)_{10}}$

\item $(BD.0E)_{16} = (1011 \; 1101.0000 \; 1110)_2 = 1 \cdot 2^7 +
1 \cdot 2^5 + 1 \cdot 2^4 + 1 \cdot 2^3 + 1 \cdot 2^2 + 1 \cdot 2^0 +
1 \cdot 2^{-5} + 1 \cdot 2^{-6} + 1 \cdot 2^{-7} = (\frac{24199}{128})_{10} =
\boldsymbol{(189.0546875)_{10}}$

\item $(41.1)_{10} = (?)_2 = (?)_{16}$
\begin{gather*}
\begin{array}{*{8}c}
(41)_{10} = (?)_2 \longrightarrow & \divr{41} & 2             \\ \cline{3-3}
                                  & \redn{1}  & \divr{20} & 2 \\ \cline{4-4}
&                                 & \redn{0}  & \divr{10} & 2 \\ \cline{5-5}
& &                               & \redn{0}  & \divr{5}  & 2 \\ \cline{6-6}
& & &                             & \redn{1}  & \divr{2}  & 2 \\ \cline{7-7}
& & & &                           & \redn{0}  & \divr{1}  & 2 \\ \cline{8-8}
& & & & &                         & \redn{1}  & \redn{0}
\end{array} \\
\longleftarrow \\
(41)_{10} = (101001)_2 = 1 \cdot 2^5 + 1 \cdot 2^3 + 1 \cdot 2^0 \\
(0.1)_{10} = (?)_2 \longrightarrow \\
\begin{array}{*{11}c}
0.1 & 0.2 & 0.4 & 0.8 & 0.6 & 0.2 & 0.4 & 0.8 & 0.6 & 0.2 & \\
\times 2 & \times 2 & \times 2 & \times 2 & \times 2 & \times 2 & \times 2 &
\times 2 & \times 2 & \times 2 & \dots \\
\redn{0}.2 & \redn{0}.4 & \redn{0}.8 & \redn{1}.6 & \redn{1}.2 & \redn{0}.4 &
\redn{0}.8 & \redn{1}.6 & \redn{1}.2 & \redn{0}.4 &
\end{array} \\
(0.1)_{10} = (0.00011001100110011 \dots)_2
\end{gather*}

Logo, $(41.1)_{10} = (101001.0\overline{0011})_2 =
(0010 \; 1001. 0001 \; \overline{1001})_2 =
\boldsymbol{(29.1\overline{9})_{16}}$. Haverá perda de dígitos significativos.

\end{alphenum}

\item $F(\beta, t, I, S) \longrightarrow F(2, 3, -3, +3) \longrightarrow$
\begin{tabular}{*{8}{|c}|}
\hline
$s_1$ & $d_1$ & $d_2$ & $d_3$ & $s_2$ & $e_1$ & $e_2$ \\
\hline
\end{tabular}
\begin{alphenum}

\item $NM = (\beta - 1) \cdot \beta^{t - 1} = (2 - 1) \cdot 2^{3 - 1} =
\boldsymbol{4}$

\item $NE = S - I + 1 = 3 - (-3) + 1 = \boldsymbol{7}$

\item $NR = 2 \cdot NM \cdot NE + 1 = \boldsymbol{57}$

\item \begin{tabular}{*{8}{|c}|}
\hline
$0$ & $1$ & $0$ & $0$ & $1$ & $1$ & $1$ \\
\hline
\end{tabular} $\longrightarrow m.p. = (0.1)_2 \cdot (2^{-3})_{10} =
(2^{-1})_{10} \cdot (2^{-3})_{10} = (0.0625)_{10}$

Logo, a região de \emph{underflow} é
$\boldsymbol{\{x \in \mathbb{R} \mid -(0.0625)_{10} < x < (0.0625)_{10}\}}$.

\begin{tabular}{*{8}{|c}|}
\hline
$0$ & $1$ & $1$ & $1$ & $0$ & $1$ & $1$ \\
\hline
\end{tabular} $\longrightarrow M.P. = (0.111)_2 \cdot (2^3)_{10} =
(0.875)_{10} \cdot (2^3)_{10} = (7)_{10}$

Logo, a região de \emph{overflow} é
$\boldsymbol{\{x \in \mathbb{R} \mid x < -(7)_{10} \cup x > (7)_{10}\}}$.

\item A precisão decimal equivalente é aproximadamente
$log_{10} (2^3) = 3 \cdot log_{10} (2) \approx \boldsymbol{0.90308998699}$.

\item $F(2, 3, 0, 6)$ (polarização $p = +3$)

\end{alphenum}

\item $F(\beta, t, I, S) \longrightarrow F(2, 3, 0, +7) \longrightarrow$
\begin{tabular}{*{8}{|c}|}
\hline
$s_1$ & $d_1$ & $d_2$ & $d_3$ & $0$ & $e_1$ & $e_2$ & $e_3$ \\
\hline
\end{tabular}
\begin{alphenum}

\item $NM = (\beta - 1) \cdot \beta^{t - 1} = (2 - 1) \cdot 2^{3 - 1} =
\boldsymbol{4}$

\item $NE = S - I + 1 = 7 - 0 + 1 = \boldsymbol{8}$

\item $NR = 2 \cdot NM \cdot NE + 1 = \boldsymbol{65}$

\item \begin{tabular}{*{8}{|c}|}
\hline
$0$ & $1$ & $0$ & $0$ & $0$ & $0$ & $0$ & $0$ \\
\hline
\end{tabular} $\longrightarrow m.p. = (0.1)_2 \cdot (2^{0})_{10} =
(2^{-1})_{10} \cdot (1)_{10} = \boldsymbol{(0.5)_{10}}$

Logo, a região de \emph{underflow} é
$\boldsymbol{\{x \in \mathbb{R} \mid -(0.5)_{10} < x < (0.5)_{10}\}}$.

\begin{tabular}{*{8}{|c}|}
\hline
$0$ & $1$ & $1$ & $1$ & $0$ & $1$ & $1$ & $1$ \\
\hline
\end{tabular} $\longrightarrow m.p. = (0.111)_2 \cdot (2^{7})_{10} =
(0.875)_{10} \cdot (2^7)_{10} = \boldsymbol{(112)_{10}}$

Logo, a região de \emph{overflow} é
$\boldsymbol{\{x \in \mathbb{R} \mid x < -(112)_{10} \cup x > (112)_{10}\}}$.

\item A precisão decimal equivalente é aproximadamente
$log_{10} (2^3) = 3 \cdot log_{10} (2) \approx \boldsymbol{0.90308998699}$.

\end{alphenum}

\item O formato de ponto flutuante de precisão dupla tem 1 bit de sinal, 11 bits
para expoente e 52 bits explícitos para decimais (o 1º bit é implícito por conta
do armazenamento do número de acordo com o padrão IEEE 754).

Também foi decidido neste padrão
\href{http://stackoverflow.com/a/2835476}{facilitar} o armazenamento do
expoente. Assim, um conceito chamado \emph{exponent bias}, calculado por
$2^{k-1} - 1$ onde $k$ é o número de bits do expoente, foi criado com esta
função. Este \emph{bias} é essencial para a codificação do expoente como um
valor \verb!unsigned!. Para obter o expoente verdadeiro, subtrai-se o
\emph{bias} do expoente representado.

Assim sendo, \emph{bias} $= 2^{11-1}-1 = 1023$. $e_{min} = 1 - 1023 = -1022$ e
$e_{max} = 2046 - 1023 = 1023$. (Os expoentes 0 e 2047 são reservados.)

Portanto, o menor número passível de ser representado com precisão dupla é
$2^{-1022} \approx \boldsymbol{2.225 \cdot 10^{-308}}$, e o maior número é
$2^{1023}$ com todos os bits da mantissa ativados, ou seja, $2^{1023} \cdot (2 -
2^{-52}) \approx \boldsymbol{1.797 \cdot 10^{308}}$. Às custas da perda de
precisão, existem números que vão abaixo da fronteira de \emph{underflow},
chamados de \href{https://en.m.wikipedia.org/wiki/Denormal_number}{subnormais}.

\begin{verbatim}
>>> 2**(-1022 - 52)
5e-324
>>> 2**(-1022)
2.2250738585072014e-308
>>> (2 - 2**(-52)) * (2**1023)
1.7976931348623157e+308
>>> float(2**1024)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
OverflowError: int too large to convert to float
\end{verbatim}

\item $log_{10} (2^{53}) = 53 \cdot log_{10} (2) \approx \boldsymbol{15.9546}$

\item \begin{discusscode}{div_by_zero.py}

\item O processo descrito em código pode ser reescrito aritmeticamente da
seguinte maneira:

\begin{equation*}
g = \frac{e}{f}
  = \frac{3 \cdot x - h}{5 \cdot y - h}
  = \frac{3 \cdot (\frac{2}{3} - h) - h}{5 \cdot (\frac{3}{5} - h) - h}
  = \frac{3 \cdot (\frac{2}{3} - \frac{1}{2}) - \frac{1}{2}}
         {5 \cdot (\frac{3}{5} - \frac{1}{2}) - \frac{1}{2}}
  = \frac{3 \cdot \frac{1}{6} - \frac{1}{2}}
         {5 \cdot \frac{1}{10} - \frac{1}{2}}
  = \frac{\frac{1}{2} - \frac{1}{2}}{\frac{1}{2} - \frac{1}{2}}
  = \frac{0}{0}
\end{equation*}

Porém, nota-se que na saída do programa, as variáveis \verb!x! e \verb!y! são
responsáveis pelo resultado válido (\verb!g! $= 1$), em virtude da imprecisão de
seu armazenamento quando $\beta = 2$ (as multiplicações realizadas nunca serão
iguais a um valor exato binariamente como $\frac{1}{2}$). Assim, como \verb!e!
$=$ \verb!f! e $e,f \neq 0$, então $\frac{e}{f} = g = 1$.

\item Saída do programa:
\begin{verbatim}
0.5000000000000000000000000000000000000000000000000000000
0.5000000000000000000000000000000000000000000000000000000

0.1666666716337203979492187500000000000000000000000000000
0.1666666666666666296592325124947819858789443969726562500

0.1000000014901161193847656250000000000000000000000000000
0.0999999999999999777955395074968691915273666381835937500

-0.0000000000000001110223024625156540423631668090820312500
-0.0000000000000001110223024625156540423631668090820312500

-0.0000000000000001110223024625156540423631668090820312500
-0.0000000000000001110223024625156540423631668090820312500

1.0000000000000000000000000000000000000000000000000000000
1.0000000000000000000000000000000000000000000000000000000\end{verbatim}

\end{discusscode}

\item \begin{discusscode}{quadratic.py}

\item O código acima simula os cálculos com precisão dupla nos dois tipos de
equação quadrática, além de imprimir o resultado arredondado para o operador
aritmético $F(10, 4, -99, +99)$ e os resultados reais.

\item Observa-se que, onde não existem subtrações internas para
calcular o resultado final, o erro relativo mostra-se muito inferior,
assim gerando resultado mais confiáveis. Utilizando precisão dupla,
os erros tornam-se irrelevantes entre si -- a diferença entre métodos
é da ordem de $1 \cdot 10^{-14}$.

\item Saída do programa:

\begin{verbatim}
-0.015 -62.09
0.07381333333333329 9.824448381387577e-05
-0.0161 -66.67
0.00044720496894402943 0.06878806059697018
\end{verbatim}

\end{discusscode}

\item \begin{alphenum}

\item \begin{itemize}

\item Erro absoluto: $\vert VA - VE \vert = \vert 1102.345 - 1100.9 \vert
= \boldsymbol{1.445}$

\item Erro relativo: $\big\vert\frac{VA - VE}{VE}\big\vert
= \big\vert\frac{1.445}{1100.9}\big\vert \approx \boldsymbol{0.00131}$

\item Percentual: $0.00131 \cdot 100 = \boldsymbol{0.131\%}$

\end{itemize}

\item \begin{itemize}

\item Erro absoluto: $\vert VA - VE \vert = \vert 0.01245 - 0.0119 \vert
= \boldsymbol{0.00055}$

\item Erro relativo: $\big\vert\frac{VA - VE}{VE}\big\vert
= \big\vert\frac{0.00055}{0.0119}\big\vert \approx \boldsymbol{0.04622}$

\item Percentual: $0.04622 \cdot 100 = \boldsymbol{4.622\%}$

\end{itemize}

\end{alphenum}

\item \begin{alphenum}

\item Sabe-se que $(10)_{10} = (1010)_2$. O cálculo da parte decimal segue
abaixo: $-(0.05)_{10} = (?)_2$
\begin{gather*}
\begin{array}{*{11}c}
0.05 & 0.1 & 0.2 & 0.4 & 0.8 & 0.6 & 0.2 & 0.4 & 0.8 & 0.6 & \\
\times 2 & \times 2 & \times 2 & \times 2 & \times 2 & \times 2 & \times 2 &
\times 2 & \times 2 & \times 2 & \dots \\
\redn{0}.1 & \redn{0}.2 & \redn{0}.4 & \redn{0}.8 & \redn{1}.6 & \redn{1}.2 &
\redn{0}.4 & \redn{0}.8 & \redn{1}.6 & \redn{1}.2 &
\end{array} \\
-(0.05)_{10} = -(0.00\overline{0011})_2 =
1 \cdot 2^{-5} \cdot -(0.\overline{1001})_2 \\
(-10.05)_{10} = (1010.0000\overline{1100})_2 = (1.0100000\overline{1100})_2
\cdot 2^{3}
\end{gather*}
$s = 1$ (sinal negativo)

$e = 3 + 127 = 130$ (polarização ou \emph{exponent bias})

O arredondamento no bit final da mantissa acontece pois a fração binária
termina por 1. A parcela binária arredondada é igual a $2^{-23} \cdot
(0.\overline{1100})_2$

Resultado final: \textbf{\begin{tabular}{*{3}{|c}|}
\hline
1 & 10000010 & 01000001100110011001101 \\
\hline
\end{tabular}}

\item Convertendo novamente o número para decimal, tem-se
$VA = (-10.050000190734863)_{10}$.

O percentual de erro é igual a
$\big\vert\frac{VA - VE}{VE}\big\vert \cdot 100
\approx \boldsymbol{1.897856 \cdot 10^{-6}\%}$.

\end{alphenum}

\item \begin{tabular}{*{3}{|c}|}
\hline
1 & 00000000 & 10000000000000000000001 \\
\hline
\end{tabular} (Número subnormal)

$e = 0, f \neq 0 \longrightarrow
v = (-1)^s \cdot \Big(\displaystyle\sum_{i=1}^{23} b_{23-i} 2^{-i} \Big)
\cdot 2^{e - 126} = (-1)^1 \cdot (2^{-1} + 2^{-23}) \cdot 2^{-126}
\approx \boldsymbol{-5.877473 \cdot 10^{-39}}$

\item \begin{alphenum}
\item Para descobrir a ordem desse número, é necessário estimar a partir do
cálculo de expoente. Ignorando o sinal e a mantissa, sabe-se que
$(1.51 \cdot 10^{37})_{10} \approx 2^{e - 127}$ (aparentemente, $0 < e < 255$).

Segue que $log_2 (1.51 \cdot 10^{37}) = log_2 (2^{e - 127})$. Logo,
$123.5058 \approx e - 127$ e, como o número de bits precisa ser arredondado
para baixo, então $123 = e - 127$ e por fim $e = 250$. O número é negativo,
então $s = 1$.

Tem-se então, $(-1.51 \cdot 10^{+37})_{10} =
(-1)^1 \cdot 2^{250 - 127} \cdot (1.f)_2 \longrightarrow
\frac{1.51 \cdot 10^{37}}{2^{123}} = (1.f)_2$. Multiplicando sucessivamente o
decimal obtido, conclui-se que $(-1.51 \cdot 10^{+37})_{10} =
(-1.011010111000010011101111010 \dots)_2 \cdot 2^{123}$.

$f = (01101011100001001110111)_2 + (1)_2 = (01101011100001001111000)_2$
(primeiros 23 bits + arredondamento)

Resultado final: \textbf{\begin{tabular}{*{3}{|c}|}
\hline
1 & 11111010 & 01101011100001001111000 \\
\hline
\end{tabular}}

\item Convertendo novamente o número para decimal, tem-se
$VA = (-1.51000004197986229847484292417978368 \cdot 10^{37})_{10}$.

O percentual de erro é igual a
$\big\vert\frac{VA - VE}{VE}\big\vert \cdot 100
\approx \boldsymbol{2.7801 \cdot 10^{-6}\%}$.

\end{alphenum}

\item \begin{alphenum}

\item $(-1.1 \cdot 10^{-41})_{10} = (-1)^1 \cdot 2^{-126} \cdot (0.f)_2$ com
$e \leq 0$, pois $log_2 (1.1 \cdot 10^{-41}) \approx -136$, o que implica em
$e = -136 + 127 = -9 < 0 \longrightarrow$ número subnormal)

Então, para descobrir a mantissa $f$, calcula-se
$\frac{1.1 \cdot 10^{-41}}{2^{-126}}$ e multiplica-se o decimal para encontrar
seu valor binário. Por fim, $(-1.1 \cdot 10^{-41})_{10} =
(-1.111010101001110111001100000 \dots)_2 \cdot 2^{-137}$.

É necessário mover o decimal para que o número possa ser representado com $e =
0$. Então, \\
$(-1.111010101001110111001100000 \dots)_2 \cdot 2^{-137} =
(-0.00000000001111010101001 \dots)_2 \cdot 2^{-126}$.

Resultado final: \textbf{\begin{tabular}{*{3}{|c}|}
\hline
1 & 00000000 & 00000000001111010101010 \\
\hline
\end{tabular}}

\item Convertendo novamente o número para decimal, tem-se
$VA = -1.1000192944949814 \cdot 10^{-41}$

O percentual de erro é igual a
$\big\vert\frac{VA - VE}{VE}\big\vert \cdot 100
= \boldsymbol{1.7540449983\overline{09} \cdot 10^{-3}\%}$.

\end{alphenum}

\item Caso seja viável calcular o resultado desejado à mão, ou utilizando
ferramentas de maior precisão, é possível verificar o erro relativo sem
maiores dificuldades. Porém, na maioria dos casos isso não acontece, e é
necessário observar como o computador se comporta nestes casos. Esta
aritmética de ponto flutuante é uma grande área de estudo do cálculo numérico.

\item[\textbf{17, 18})] \begin{discusscode}{maclaurin.py}

\item O decimal desejado foi retirado do
\href{http://www.wolframalpha.com/input/?i=e%5E(-.111)}{Wolfram Alpha}, para
comparação com os resultados calculados pelo programa em variáveis de precisão
simples e dupla, respectivamente. O erro da variável de precisão simples é maior
pela quantidade reduzida de bits disponíveis para armazenar a parte decimal do
resultado.

\item Novamente, a função \emph{reduce} é utilizada para simular o cálculo da
série de Maclaurin com os argumentos fornecidos.

\item Saída do programa:
\begin{verbatim}
0.00069152325516942810771509053680006218201015144586563110351562500%
0.00069138016857893662848316695956896182906348258256912231445312500%
\end{verbatim}

\end{discusscode}

\end{arabenum}

\end{document}
